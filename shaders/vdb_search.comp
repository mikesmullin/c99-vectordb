#version 450

layout(local_size_x = 256) in;

// Bindings
layout(std430, binding = 0) readonly buffer IndexBuffer {
    float data[]; // [count * dim]
} index_vectors;

layout(std430, binding = 1) readonly buffer QueryBuffer {
    float data[]; // [dim]
} query_vector;

layout(std430, binding = 2) writeonly buffer ScoreBuffer {
    float data[]; // [count]
} scores;

layout(push_constant) uniform Constants {
    uint count;
    uint dim;
    uint metric; // 0=L2, 1=Cosine, 2=Dot
} params;

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= params.count) return;

    float score = 0.0;
    float norm_a = 0.0; // query
    float norm_b = 0.0; // index vec
    
    uint dim = params.dim;
    uint offset = id * dim;

    // Loop unrolling could happen here by compiler
    for (uint i = 0; i < dim; i++) {
        float q = query_vector.data[i];
        float v = index_vectors.data[offset + i];
        
        score += q * v;
        norm_a += q * q;
        norm_b += v * v;
    }

    if (params.metric == 1) { // Cosine
        if (norm_a > 0.0 && norm_b > 0.0) {
            score = score / (sqrt(norm_a) * sqrt(norm_b));
        } else {
            score = 0.0;
        }
    }
    // Else Dot Product (metric 2) -> score is already dot
    // L2 (metric 0) -> TODO if needed, but we focus on Cosine/Dot

    scores.data[id] = score;
}
